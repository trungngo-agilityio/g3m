part of g3.stimpack.meta.techlab;

class StimGenMetaPack implements Node {
  final StimMetaPack pack;

  StimpackCodeConfig _config;

  /// The external packs referred by this pack.
  /// This can be determined by figure out the types user by the other
  /// package.
  Set<StimMetaPack> _externalPacks;

  /// The external types used.
  Set<StimMetaType> _externalTypes;

  StimGenMetaPack(this.pack);

  @override
  Node build(BuildContext context) {
    // This file is rather complex. Before building anything,
    // set up commonly access variables first.
    _preBuild(context);

    final fileName = _config.packFileNameOf(pack);

    // Generates a dart file that defines the entry point
    // for the whole pack.
    return DartCodeFile.of(
      fileName,
      package: _config.codePackageLibraryOf(pack),
      parts: _parts(_config),
      imports: _imports(_config),
      body: _extension(_config),
      classes: [
        // The abstract class that provides the pack public interface.
        _abstractTypeClass(_config),

        // The internal implementation.
        _typeClass(_config),
      ],
    );
  }

  void _preBuild(BuildContext context) {
    _config = context.dependOnAncestorNodeOfExactType<StimpackCodeConfig>();
    _externalPacks = <StimMetaPack>{};
    _externalTypes = <StimMetaType>{};

    // Finds all external packs that this pack depends on.
    for (final type in pack.types) {
      for (final field in type.fields) {
        final fieldTypePack = field.type?.pack;
        if (fieldTypePack?.isNotNone == true && fieldTypePack != pack) {
          _externalPacks.add(fieldTypePack);
          _externalTypes.add(field.type);
        }
      }
    }

    // Removes all preset that points to meta pack.
    // This is forbidden.
    var presets = pack.presets.where((preset) {
      final typePack =
          preset.type?.pack?.isNotNone == true ? preset.type.pack : pack;

      return typePack?.name?.camel()?.toString() != 'meta' ||
          preset.type.name.camel().toString() != 'type';
    }).toSet();

    // Adds a new preset in to model the pack.
    final metaPreset = stimpack.meta.preset.ofValues('',
        type: stimpack.meta.type.forMeta.type,
        values: pack.types.map((e) => e.name.camel().toString()).toList());

    pack.presets = metaPreset + presets;
  }

  /// Builds the list of code imports.
  ///
  List<CodeImport> _imports(StimpackCodeConfig config) {
    final imports = <CodeImport>[
      // imports the base stimpack
      CodeImport.of(path: 'package:g3m/stimpack_base.dart'),
      // Imports additional package refers by this package.
    ];

    // Imports the meta package if the current package is not meta
    if (pack.name.camel().toString() != 'meta') {
      _externalPacks.add(stimpack.meta.meta);
    }

    // Imports all external packs
    for (final externalPack in _externalPacks.toSet()) {
      imports.add(config.codePackImportOf(externalPack));
    }

    return imports;
  }

  /// Builds the list of parts to be included into this library dart file.
  /// These parts are generated via [StimGenMetaType], [StimGenMetaPreset],
  /// and [StimGenMetaTypeField].
  ///
  List<String> _parts(StimpackCodeConfig config) {
    final parts = <String>[];
    parts.add(config.presetFileNameOf(pack));
    parts.add('../' + config.initPackFileNameOf(pack).toString());

    for (final i in pack.types) {
      // Includes the type definition file
      parts.add(config.typeFileNameOf(pack, i));

      for (final j in i.fields) {
        // Include the type field definition file.
        parts.add(config.typeFieldFileNameOf(pack, i, j));
      }
    }

    return parts;
  }

  /// Generates an abstract class like [StimMeta]
  /// that provides public interfaces for users.
  ///
  /// Notes: [_typeClass] generates the implementation class for this interface.
  ///
  CodeClass _abstractTypeClass(StimpackCodeConfig config) {
    final properties = <CodeProperty>[
      // This meta property provides definitions of all types,
      // fields, etc defined in the pack. Given this meta information,
      // the pack can regenerate itself.
      CodeProperty.of(
          name: 'meta',
          type: 'stim meta pack',
          getter: CodePropertyGetter.of(body: null)),
    ];

    for (final type in pack.types) {
      // For each data type in the pack, this scope property
      // shall provides the ability to create concrete symbol within
      // the scope.
      properties.add(CodeProperty.of(
        name: type.name,
        type: config.scopeClassNameOf(pack, type),
        getter: CodePropertyGetter.of(body: null),
      ));
    }

    // Generates an abstract pack class.
    return CodeClass.of(
      name: config.packClassNameOf(pack),
      isAbstract: true,
      properties: properties,
    );
  }

  /// Generates an implementation for the abstract pack class (generated by
  /// [_abstractTypeClass] function.)
  ///
  CodeClass _typeClass(StimpackCodeConfig config) {
    // ------------------------------------------------------------------------
    // fields & properties
    // ------------------------------------------------------------------------

    // Private meta field
    final metaField =
        CodeField.of(name: 'meta', type: 'stim meta pack', isPrivate: true);

    // This is the list of fields to be generated in the class.
    final fields = <CodeField>[metaField];

    // This is the list of properties to be generated in the class.
    final properties = <CodeProperty>[
      CodeProperty.ofField(field: metaField, isOverride: true, getter: true),
    ];

    // This is the array of scopes init expressions, to be putted inside
    // the class constructor.
    final scopeFieldInitExprList = <Node>[];

    // This is the array of field init expressions, to be putted inside
    // the void init() function.
    final fieldInitFunctionCallList = <Node>[];

    // Loops through all types in the pack, for each type, generate
    // a field for the scope implementation, a property for readonly
    // scope access. An example of property is [_StimMetaMetaImpl._type]
    // and [_StimMetaMetaImpl.type].
    //
    for (final type in pack.types) {
      var scopeImplClass = config.scopeImplClassNameOf(pack, type);
      final field = CodeField.of(
        name: type.name,
        type: scopeImplClass,
        isPrivate: true,
      );

      final property = CodeProperty.ofField(
        field: field,
        isOverride: true,
        getter: true,
      );

      fields.add(field);
      properties.add(property);

      // Adds an expression to invoke constructor to create scope fields.
      scopeFieldInitExprList.add(CodeAssignExpr.of(
          field.name, CodeConstructorCall.of(className: scopeImplClass)));

      // Add an expression to invoke init function of scope fields.
      final initFunctionCall = CodeFunctionCall.of(name: 'init');
      fieldInitFunctionCallList
          .add(CodeAccessExpr.of(field.name, initFunctionCall));
    }

    // Adds field and properties for getting presets.
    for (final preset in pack.presets) {
      final className = _config.presetClassNameOf(pack, preset);
      final fieldName = _config.presetFieldNameOf(pack, preset);

      final field = CodeField.of(
        name: fieldName,
        type: className,
        isPrivate: true,
      );

      fields.add(field);

      // Adds an expression to invoke constructor to create scope fields.
      scopeFieldInitExprList.add(CodeAssignExpr.of(
          field.name, CodeConstructorCall.of(className: className)));

      // Add an expression to invoke init function of scope fields.

      final type = preset.type;
      var scope = '${type.name.camel()}';
      if (type.pack?.isNotNone == true && type.pack != pack) {
        // The type come from a different pack.
        scope = 'stimpack.${type.pack.name}.${scope}';
      } else {
        // The type come from the internal pack.
        scope = '_${scope}';
      }

      final initFunctionCall = CodeFunctionCall.of(name: 'init', args: [
        CodeRef.of(scope),
      ]);
      fieldInitFunctionCallList
          .add(CodeAccessExpr.of(field.name, initFunctionCall));
    }

    // ------------------------------------------------------------------------
    // constructors
    // ------------------------------------------------------------------------

    // The constructor just need to create all scopes.
    final constructor = CodeConstructor.of(
      body: scopeFieldInitExprList,
    );

    // ------------------------------------------------------------------------
    // _buildMeta() function
    // ------------------------------------------------------------------------

    final buildMetaFunction = CodeFunction.of(
      name: 'build meta',
      isPrivate: true,
      returns: 'void',
      body: _buildMetaFunctionBody(config),
    );

    // ------------------------------------------------------------------------
    // _buildValues() function
    // ------------------------------------------------------------------------

    final buildValuesFunction = CodeFunction.of(
      name: 'buildValues',
      isPrivate: true,
      returns: 'void',
      comment: 'This function shall be call during the init process.',
      body: CodeComment.of(
        'build all preset values here',
      ),
    );

    // ------------------------------------------------------------------------
    // init() function
    // ------------------------------------------------------------------------

    final initPackFunctionName = config.initPackFunctionNameOf(pack);
    final initFunction = CodeFunction.of(name: 'init', returns: 'void', body: [
      ...fieldInitFunctionCallList,
      '_buildMeta();\n',
      CodeFunctionCall.of(name: initPackFunctionName, args: CodeRef.ofThis()),
    ]);

    // ------------------------------------------------------------------------
    // Generates final class.
    // ------------------------------------------------------------------------

    return CodeClass.of(
      name: config.packImplClassNameOf(pack),
      implements: config.packClassNameOf(pack),
      fields: fields,
      properties: properties,
      constructors: constructor,
      functions: [
        initFunction,
        buildMetaFunction,
      ],
    );
  }

  Node _buildMetaFunctionBody(StimpackCodeConfig config) {
    final forPack = ('for' >> pack.name).camel();
    final nodes = <Node>[
      Container([
        pack.name.toString() == 'meta'
            ? 'final meta = this;\n'
            : 'final meta = stimpack.meta;\n',
        'final pack = meta.pack.of(\'${pack.name.camel()}\');\n',
        'final f = meta.field, t = meta.type, p = meta.preset, v = meta.value, k = meta.kind;\n',
        '\n',
      ]),
    ];

    for (final i in pack.types) {
      // stop if this field does not have and fields.
      if (i.fields.isEmpty) continue;

      final fieldDefs = <Node>[];

      for (final field in i.fields) {
        final fieldName = field.name;
        final fieldTypeName =
            _config.publicMetaTypeName(pack, field.type, prefix: 't');

        final fieldDef = Container([
          '\nf.of(\'',
          fieldName.camel(),
          '\'',
          field.isSet ? Text.of(', kind: k.set') : null,
          ', type: ',
          fieldTypeName,
          ')',
        ]);

        fieldDefs.add(fieldDef);
      }

      final typeName = _config.publicMetaTypeName(pack, i, prefix: 't');
      nodes.add(Container([
        typeName,
        '.fields = f.noneSet +\n',
        Indent(
            Join.of(
              ' + ',
              fieldDefs.toList(),
            ),
            level: 2),
        ';\n\n',
      ]));
    }

    // Builds the type presets.
    final presetDefs = <Node>[];

    for (final i in pack.presets) {
      final presetName = i.name.camel();
      if (i.values.isNotEmpty != true) continue;
      final valueDefs = <Node>[];
      for (final j in i.values) {
        valueDefs.add(
          Container(['\nv.of(\'', j.name, '\')']),
        );
      }

      final type = i.type;
      final presetTypeName =
          _config.publicMetaTypeName(pack, type, prefix: 't');

      final presetDef = Container([
        '\np.of(\'',
        presetName,
        '\', type: ${presetTypeName}, values: \n',
        Indent(
            Join.of(
              ' + ',
              valueDefs,
            ),
            level: 3),
        ',)\n',
      ]);

      presetDefs.add(presetDef);
    }

    if (presetDefs.isNotEmpty) {
      nodes.add(Container([
        'pack.presets = p.noneSet +\n',
        Indent(Join.of(' + ', presetDefs.toList()), level: 2),
        ';\n\n',
      ]));
    }

    nodes.add(Text.of('pack.types = t.${forPack}.all;\n'));

    nodes.add(
      Text.of('pack.types.pack.set(pack);\n'),
    );

    nodes.add(
      Text.of('_meta = pack;\n'),
    );

    return Container(nodes);
  }

  Node _extension(StimpackCodeConfig config) {
    // TODO: Fix this after extension support
    final template = ''' 
{{ packClass }}  _{{ packClass.camel }};

extension {{ packClass }}StimpackExtension on Stimpack {
  {{ packClass }} get {{ packName.camel }} {
    if (_{{ packClass.camel }} == null) {
      final impl = _{{ packClass.camel }} = {{ packImplClass }}();
      impl.init();
      return _{{ packClass.camel }};
    }
    
    return _{{ packClass.camel }};
  }
}
    ''';
    return Mustache.template(template, values: {
      'packName': pack.name.camel(),
      'packClass': _config.packClassNameOf(pack),
      'packImplClass': _config.packImplClassNameOf(pack),
    });
  }
}
