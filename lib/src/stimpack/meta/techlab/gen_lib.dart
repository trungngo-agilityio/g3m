part of g3.stimpack.meta.techlab;

class StimGenMetaPack implements Node {
  final StimModelPackage pack;

  StimpackCodeConfig _config;

  StimName _packClassName;

  /// The external packs referred by this pack.
  /// This can be determined by figure out the types user by the other
  /// package.
  Set<StimModelPackage> _externalPacks;

  /// The external types used.
  Set<StimModelType> _externalTypes;

  StimName _metaTypeClassName;

  CodeField _packInstanceField;
  CodeField _metaTypeListField;
  CodeField _metaPackageField;

  StimGenMetaPack(this.pack);

  @override
  Node build(BuildContext context) {
    // This file is rather complex. Before building anything,
    // set up commonly access variables first.
    _preBuild(context);

    final fileName = _config.packFileNameOf(pack);

    // Generates a dart file that defines the entry point
    // for the whole pack.
    return DartCodeFile.of(
      fileName,
      package: _config.codePackageLibraryOf(pack),
      parts: _buildPartList(),
      imports: _buildImportList(),
      fields: [
        _buildPackInstanceField(),
      ],
      classes: [
        // The internal implementation.
        _buildPackClassDef(),
        _buildSymbolMetaTypesClassDef(),
      ],
      extensions: [
        _buildPackExtensionOnStimpack(),
        _buildSymbolMetaTypesExtensionDef(),
      ],
    );
  }

  void _preBuild(BuildContext context) {
    _config = context.dependOnAncestorNodeOfExactType<StimpackCodeConfig>();
    _packClassName = _config.packClassNameOf(pack);

    _metaTypeClassName = _config.metaTypesClassNameOf(pack);
    _metaTypeListField = CodeField.of(
      name: 'meta',
      isFinal: true,
      type: _metaTypeClassName,
    );

    final modelMeta = stimpack.model.type.model;
    _metaPackageField = CodeField.of(
      name: 'meta package',
      isPrivate: true,
      type: modelMeta.package.name,
    );

    final p = stimpack.model.package;
    final systemPackages = {p.dart, p.model};

    /// Makes every pack depends on the model pack.
    _externalPacks = <StimModelPackage>{p.model};

    // Finds all external packs that this pack depends on.
    final processed = <StimModelType>{};
    final queue = Queue.of(pack.types);

    while (queue.isNotEmpty) {
      final t = queue.removeFirst();
      if (processed.contains(t)) continue;
      processed.add(t);

      var tPackage = t.package;
      if (tPackage != pack && !systemPackages.contains(tPackage)) {
        _externalPacks.add(tPackage);
      }

      if (t.collection != null) queue.add(t.collection);
      if (t.item != null) queue.add(t.item);

      if (t.fields != null) {
        for (final field in t.fields) {
          queue.add(field.type);
        }
      }
    }
  }

  /// Builds the list of code imports.
  ///
  List<CodeImport> _buildImportList() {
    final imports = <CodeImport>[
      // imports the base stimpack
      // TODO: Makes this a external package
      CodeImport.of(path: 'package:g3m/stimpack_core.dart'),
      CodeImport.of(path: 'package:g3m/stimpack_meta.dart'),
      CodeImport.of(path: 'package:meta/meta.dart'),
      // Imports additional package refers by this package.
    ];

    // Imports all external packs
    for (final externalPack in _externalPacks.toSet()) {
      imports.add(_config.codePackImportOf(externalPack));
    }

    return imports;
  }

  /// Builds the list of parts to be included into this library dart file.
  /// These parts are generated via [StimGenMetaType], [StimGenMetaPreset],
  /// and [StimGenMetaTypeField].
  ///
  List<String> _buildPartList() {
    final parts = <String>[];
    parts.add('../' + _config.initPackFileNameOf(pack).toString());

    for (final i in pack.types) {
      // Includes the type definition file
      parts.add(_config.typeFileNameOf(pack, i));
    }

    return parts;
  }

  /// Generates an implementation for the abstract pack class (generated by
  /// [_abstractTypeClass] function.)
  ///
  CodeClass _buildPackClassDef() {
    // ------------------------------------------------------------------------
    // fields & properties
    // ------------------------------------------------------------------------

    // This is the list of fields to be generated in the class.
    final fields = <CodeField>[_metaTypeListField, _metaPackageField];

    // This is the list of properties to be generated in the class.
    final properties = <CodeProperty>[];

    // This is the array of scopes init expressions, to be putted inside
    // the class constructor.
    final inits = <Node>[
      // Initializes the meta field with a final instance.
      CodeAssignExpr.of(
        CodeRef.of(_metaTypeListField),
        CodeConstructorCall.of(className: _metaTypeClassName),
      ),
    ];

    // Loops through all types in the pack, for each type, generate
    // a field for the scope implementation, a property for readonly
    // scope access. An example of property is [_StimMetaMetaImpl._type]
    // and [_StimMetaMetaImpl.type].
    //
    for (final type in pack.types) {
      final symbolClassName = _config.symbolClassNameOf(type);
      final scopeImplClass = _config.scopeClassNameOf(type);
      final fieldName = _config.fieldNameOfType(type);

      final field = CodeField.of(
        name: fieldName,
        type: scopeImplClass,
        isFinal: true,
        comment: '''Scope class for constructing all "${fieldName}" symbols, 
typed of [$symbolClassName]."''',
      );

      fields.add(field);

      // Adds an expression to invoke constructor to create scope fields.
      inits.add(
        CodeAssignExpr.of(
          CodeRef.of(field),
          CodeConstructorCall.of(className: scopeImplClass),
        ),
      );
    }

    // ------------------------------------------------------------------------
    // _buildMeta() function
    // ------------------------------------------------------------------------

    final buildMetaFunction = CodeFunction.of(
      name: 'build meta',
      isPrivate: true,
      returns: 'void',
      body: _buildMetaFunctionBody(_config),
    );

    // The constructor just need to create all scopes.
    final initPackFunctionName = _config.initPackFunctionNameOf(pack);

    // ------------------------------------------------------------------------
    // constructors
    // ------------------------------------------------------------------------

    final constructorArgs = <CodeArg>[];
    for (final p in _externalPacks) {
      constructorArgs.add(
        CodeArg.of(
          name: p.name,
          type: _config.packClassNameOf(p),
        ),
      );
    }

    final constructor = CodeConstructor.of(
      requiredArgs: constructorArgs,
      init: [
        ...inits,
        CodeFunctionCall.ofSuper(
          args: CodeStringLiteral.of(pack.name),
        ),
      ],
      body: [
        '\n',
        CodeFunctionCall.of(
          name: '_buildMeta',
          comment:
              '''Builds the meta definition that defines the structure of this pack.''',
        ),
        '\n',
        CodeFunctionCall.of(
          name: initPackFunctionName,
          args: CodeRef.ofThis(),
          comment: '''Call custom pack initialization code, this code is
not overwritten during pack re-generation. ''',
        ),
      ],
    );

    // ------------------------------------------------------------------------
    // Generates final class.
    // ------------------------------------------------------------------------

    return CodeClass.of(
      name: _packClassName,
      extend: 'stim pack',
      fields: fields,
      properties: properties,
      constructors: constructor,
      functions: [
        buildMetaFunction,
      ],
    );
  }

  Node _buildMetaFunctionBody(StimpackCodeConfig config) {
    final nodes = <Node>[
      Container([
        pack.name.toString() == 'model'
            ? 'final m = this;\n'
            : 'final m = stimpack.model;\n',
        'final mp = _metaPackage = m.package.of(name: \'${pack.name.camel()}\');\n',
        'final f = m.field, t = m.type;\n',
        '\n',
      ]),
    ];

    final typeDefs = <Node>[];
    final buildFields = <Node>[];

    for (final type in pack.types) {
      final fieldName = _config.fieldNameOfType(type);
      final args = <Node>[
        CodeNameArgExpr.of('name', CodeStringLiteral.of(fieldName)),
        CodeNameArgExpr.of('package', CodeRef.of('mp')),
      ];

      if (type.tags?.isNotEmpty == true) {
        final values = CodeSetLiteral.of(
          type.tags.map(
            (e) => CodeStringLiteral.of(e.name),
          ),
        );

        args.add(CodeNameArgExpr.of('values', values));
      }

      final typeOfCall = CodeFunctionCall.of(
        instance: 't',
        name: 'symbolOf',
        args: args,
      );
      // stop if this field does not have and fields.

      typeDefs.add(Container([
        '\n',
        CodeComment.of('Builds type "${fieldName}"'),
        CodeAssignExpr.of('meta.${fieldName}', typeOfCall),
      ]));

      if (type.fields?.isNotEmpty != true) continue;

      final fieldDefs = <Node>[];

      for (final field in type.fields) {
        final fieldTypeName = _buildTypeName(field.type);

        Node def = CodeFunctionCall.of(
          instance: 'f',
          name: 'of',
          args: [
            CodeNameArgExpr.of('name', CodeStringLiteral.of(field.name)),
            CodeNameArgExpr.of('type', fieldTypeName)
          ],
        );

        if (field.isRequired) {
          def = CodeFunctionCall.of(instance: def, name: 'required');
        }

        fieldDefs.add(
          Container([
            '\n\n',
            CodeComment.of('field "${fieldName}"'),
            def,
          ]),
        );
      }

      buildFields.add(
        Container([
          '\n\n',
          CodeComment.of('Builds fields for type "${fieldName}"'),
          CodeAssignExpr.of(
            'meta.${fieldName}.fields',
            CodeSetLiteral.of(fieldDefs),
          ),
        ]),
      );
    }

    return Container([
      ...nodes,
      ...typeDefs,
      ...buildFields,
    ]);
  }

  Node _buildTypeName(StimModelType type, [Set<StimModelType> processing]) {
    assert(processing?.contains(type) != true,
        'Error. recursive type definition found.');
    processing = Set.of(processing ?? {})..add(type);

    if (type.isCollection) {
      if (type.isDartSet) {
        return Container([
          't.setOf(item: ',
          _buildTypeName(type.item, processing),
          ')',
        ]);
      } else if (type.isDartList) {
        return Container([
          't.listOf(item: ',
          _buildTypeName(type.item, processing),
          ')',
        ]);
      } else {
        throw 'Do not support custom collection type ${type.collection}';
      }
    } else if (type.isDartPrimitive) {
      // This type come from outside.
      final name = _config.fieldNameOfType(type);
      return Text.of('t.${name}');
    } else if (type.package.name != pack.name) {
      // This type come from outside.
      final name = _config.fieldNameOfType(type);
      return Text.of('t.${type.package.name}.${name}');
    } else {
      // This type is defined in the package.
      final name = _config.fieldNameOfType(type);
      return Text.of('meta.${name}');
    }
  }

  CodeField _buildPackInstanceField() {
    return _packInstanceField = CodeField.of(
      name: pack.name,
      type: _packClassName,
      isPrivate: true,
      comment: 'The only instance of the [$_packClassName] pack.',
    );
  }

  CodeExtension _buildPackExtensionOnStimpack() {
    /// The pack class className.
    final className = _config.packExtensionClassNameOf(pack);
    final constructorArgs = <Node>[];
    for (final p in _externalPacks) {
      constructorArgs.add(CodeRef.of('stimpack.${p.name.camel()}'));
    }
    final lazyInitProp = CodeProperty.of(
      name: _packInstanceField.name,
      type: _packInstanceField.type,
      getter: CodePropertyGetter.of(
        body: CodeReturn.of(
          CodeAssignIfNullExpr.of(
            _packInstanceField,
            CodeConstructorCall.of(
              className: _packInstanceField.type.name,
              args: constructorArgs,
            ),
          ),
        ),
      ),
    );

    return CodeExtension.of(
      name: className,
      on: 'stimpack root',
      properties: [lazyInitProp],
      comment: '''
Provides global access to the "${pack.name}" pack. Only one instance of the pack 
is created. During the creation, other packs that this pack depends on might 
be created as well.
 ''',
    );
  }

  CodeClass _buildSymbolMetaTypesClassDef() {
    final className = _config.metaTypesClassNameOf(pack);

    final fields = <CodeField>[];
    final tModelType = stimpack.model.type.model.type;
    for (final type in pack.types) {
      final name = _config.fieldNameOfType(type);
      final typeName = _config.symbolClassNameOf(tModelType);
      fields.add(CodeField.of(name: name, type: typeName));
    }

    return CodeClass.of(name: className, fields: fields);
  }

  CodeExtension _buildSymbolMetaTypesExtensionDef() {
    final modelTypeClassName =
        _config.scopeClassNameOf(stimpack.model.type.model.type);

    final extensionClassName = _config.metaTypesExtensionClassNameOf(pack);

    final prop = CodeProperty.of(
      name: pack.name,
      type: _metaTypeClassName,
      getter: CodePropertyGetter.of(
        body: Container([
          CodeComment.of('Gets the type meta through stimpack public '
              'instance to trigger lazy init of the pack.'),
          CodeReturn.of(
            CodeAccessExpr.of('stimpack.${pack.name.camel()}',
                CodeRef.of(_metaTypeListField)),
          )
        ]),
      ),
    );
    return CodeExtension.of(
      name: extensionClassName,
      on: modelTypeClassName,
      properties: [prop],
    );
  }
}
