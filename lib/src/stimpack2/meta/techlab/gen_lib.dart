part of g3.stimpack2.meta.techlab;

class StimGenMetaPack implements Node {
  final StimModelPackage pack;

  StimpackCodeConfig _config;

  StimName _packClassName;

  /// The external packs referred by this pack.
  /// This can be determined by figure out the types user by the other
  /// package.
  Set<StimModelPackage> _externalPacks;

  /// The external types used.
  Set<StimModelType> _externalTypes;

  StimGenMetaPack(this.pack);

  @override
  Node build(BuildContext context) {
    // This file is rather complex. Before building anything,
    // set up commonly access variables first.
    _preBuild(context);

    final fileName = _config.packFileNameOf(pack);

    // Generates a dart file that defines the entry point
    // for the whole pack.
    return DartCodeFile.of(
      fileName,
      package: _config.codePackageLibraryOf(pack),
      parts: _parts(),
      imports: _imports(),
      body: _extension(),
      classes: [
        // The internal implementation.
        _typeClass(),
      ],
    );
  }

  void _preBuild(BuildContext context) {
    _config = context.dependOnAncestorNodeOfExactType<StimpackCodeConfig>();
    _packClassName = _config.packClassNameOf(pack);
    _externalPacks = <StimModelPackage>{};
    _externalTypes = <StimModelType>{};

    // Finds all external packs that this pack depends on.
    for (final type in pack.types) {
      if (type.fields == null) continue;

      for (final field in type.fields) {
        final fieldTypePack = field.type?.package;
        if (fieldTypePack != pack) {
          _externalPacks.add(fieldTypePack);
          _externalTypes.add(field.type);
        }
      }
    }
  }

  /// Builds the list of code imports.
  ///
  List<CodeImport> _imports() {
    final imports = <CodeImport>[
      // imports the base stimpack
      CodeImport.of(path: 'package:g3m/stimpack2_core.dart'),
      // Imports additional package refers by this package.
    ];

    // Imports all external packs
    for (final externalPack in _externalPacks.toSet()) {
      imports.add(_config.codePackImportOf(externalPack));
    }

    return imports;
  }

  /// Builds the list of parts to be included into this library dart file.
  /// These parts are generated via [StimGenMetaType], [StimGenMetaPreset],
  /// and [StimGenMetaTypeField].
  ///
  List<String> _parts() {
    final parts = <String>[];
    parts.add('../' + _config.initPackFileNameOf(pack).toString());

    for (final i in pack.types) {
      // Includes the type definition file
      parts.add(_config.typeFileNameOf(pack, i));
    }

    return parts;
  }

  /// Generates an implementation for the abstract pack class (generated by
  /// [_abstractTypeClass] function.)
  ///
  CodeClass _typeClass() {
    // ------------------------------------------------------------------------
    // fields & properties
    // ------------------------------------------------------------------------

    // Private meta field
    final metaField =
        CodeField.of(name: 'meta', type: 'stim meta pack', isPrivate: true);

    // This is the list of fields to be generated in the class.
    final fields = <CodeField>[metaField];

    // This is the list of properties to be generated in the class.
    final properties = <CodeProperty>[];

    // This is the array of scopes init expressions, to be putted inside
    // the class constructor.
    final scopeInits = <Node>[];

    // Loops through all types in the pack, for each type, generate
    // a field for the scope implementation, a property for readonly
    // scope access. An example of property is [_StimMetaMetaImpl._type]
    // and [_StimMetaMetaImpl.type].
    //
    for (final type in pack.types) {
      final symbolClassName = _config.symbolClassNameOf(pack, type);
      final scopeImplClass = _config.scopeClassNameOf(pack, type);
      final fieldName = _config.fieldNameOfType(type);

      final field = CodeField.of(
        name: fieldName,
        type: scopeImplClass,
        isFinal: true,
        comment: '''Scope class for constructing all "${fieldName}" symbols, 
typed of [$symbolClassName]."''',
      );

      fields.add(field);

      // Adds an expression to invoke constructor to create scope fields.
      scopeInits.add(
        CodeAssignExpr.of(
          CodeRef.of(field),
          CodeConstructorCall.of(className: scopeImplClass),
        ),
      );
    }

    // ------------------------------------------------------------------------
    // _buildMeta() function
    // ------------------------------------------------------------------------

    final buildMetaFunction = CodeFunction.of(
      name: 'build meta',
      isPrivate: true,
      returns: 'void',
      body: _buildMetaFunctionBody(_config),
    );

    // The constructor just need to create all scopes.
    final initPackFunctionName = _config.initPackFunctionNameOf(pack);

    // ------------------------------------------------------------------------
    // constructors
    // ------------------------------------------------------------------------

    final constructor = CodeConstructor.of(init: [
      ...scopeInits,
      CodeFunctionCall.ofSuper(
        args: CodeStringLiteral.of(pack.name),
      ),
    ], body: [
      '\n',
      CodeFunctionCall.of(
        name: CodeRef.of(buildMetaFunction),
        comment:
            '''Builds the meta definition that defines the structure of this pack.''',
      ),
      '\n',
      CodeFunctionCall.of(
        name: initPackFunctionName,
        args: CodeRef.ofThis(),
        comment: '''Call custom pack initialization code, this code is
not overwritten during pack re-generation. ''',
      ),
    ]);

    // ------------------------------------------------------------------------
    // Generates final class.
    // ------------------------------------------------------------------------

    return CodeClass.of(
      name: _packClassName,
      extend: 'stim pack',
      fields: fields,
      properties: properties,
      constructors: constructor,
      functions: [
        buildMetaFunction,
      ],
    );
  }

  Node _buildMetaFunctionBody(StimpackCodeConfig config) {
    final nodes = <Node>[
      Container([
        pack.name.toString() == 'model'
            ? 'final m = this;\n'
            : 'final m = stimpack.model;\n',
        'final pack = model.package.of(\'${pack.name.camel()}\');\n',
        'final f = m.field, t = m.type;\n',
        '\n',
      ]),
    ];

    final typeDefs = <Node>[];
    final buildFields = <Node>[];

    for (final type in pack.types) {
      final fieldName = _config.fieldNameOfType(type);
      final args = <Node>[
        CodeNameArgExpr.of('name', CodeStringLiteral.of(fieldName)),
        CodeNameArgExpr.of('package', CodeRef.of('pack')),
      ];

      if (type.tags?.isNotEmpty == true) {
        final values = CodeSetLiteral.of(
          type.tags.map(
            (e) => CodeStringLiteral.of(e.name),
          ),
        );

        args.add(CodeNameArgExpr.of('values', values));
      }

      final typeOfCall = CodeFunctionCall.of(
        instance: 't',
        name: 'symbolOf',
        args: args,
      );
      // stop if this field does not have and fields.

      typeDefs.add(Container([
        '\n',
        CodeComment.of('Builds type "${fieldName}"'),
        CodeAssignExpr.of('xt.${fieldName}', typeOfCall),
      ]));

      if (type.fields?.isNotEmpty != true) continue;

      final fieldDefs = <Node>[];

      for (final field in type.fields) {
        final fieldTypeName = _buildTypeName(field.type);

        Node def = CodeFunctionCall.of(
          instance: 'f',
          name: 'of',
          args: [
            CodeStringLiteral.of(field.name),
            CodeNameArgExpr.of('type', fieldTypeName)
          ],
        );

        if (field.isRequired) {
          def = CodeFunctionCall.of(instance: def, name: 'required');
        }

        fieldDefs.add(
          Container([
            '\n\n',
            CodeComment.of('field "${fieldName}"'),
            def,
          ]),
        );
      }

      buildFields.add(
        Container([
          '\n\n',
          CodeComment.of('Builds fields for type "${fieldName}"'),
          CodeAssignExpr.of(
            'xt.${fieldName}.fields',
            CodeSetLiteral.of(fieldDefs),
          ),
        ]),
      );
    }

    nodes.add(
      Text.of('_meta = pack;\n'),
    );

    return Container([
      ...nodes,
      ...typeDefs,
      ...buildFields,
    ]);
  }

  Node _buildTypeName(StimModelType type, [Set<StimModelType> processing]) {
    if (type.isCollection) {
      if (type.isDartSet) {
        return Container([
          't.setOf(item: ',
          _buildTypeName(type.item),
          ')',
        ]);
      } else if (type.isDartList) {
        return Container([
          't.listOf(item: ',
          _buildTypeName(type.item),
          ')',
        ]);
      } else {
        throw 'Do not support custom collection type ${type.collection}';
      }
    } else if (type.package.name != pack.name) {
      // This type come from outside.
      final name = _config.fieldNameOfType(type);
      return Text.of('stimpack.${type.package.name}.${name}');
    } else {
      // This type is defined in the package.
      final name = _config.fieldNameOfType(type);
      return Text.of('xt.${name}');
    }
  }

  Node _extension() {
    /// The pack class className.
    final className = _config.packExtensionClassNameOf(pack);

    final instanceField = CodeField.of(
      name: pack.name,
      type: _packClassName,
      isPrivate: true,
      comment: 'The only instance of the [$_packClassName] pack.',
    );

    final lazyInitInstanceProp = _lazyInitCodeProperty(instanceField);

    final extension = CodeExtension.of(
      name: className,
      on: 'stim pack',
      properties: [lazyInitInstanceProp],
      comment: '''
Provides global access to the "${pack.name}" pack. Only one instance of the pack 
is created. During the creation, other packs that this pack depends on might 
be created as well.
 ''',
    );

    return Container([
      instanceField,
      extension,
    ]);
  }
}
